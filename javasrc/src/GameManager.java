import edu.kit.informatik.Terminal;
import java.util.ArrayList;
/**
 * The GameManager defines the Turns and checks for victory conditions
 * @author dahms
 * @version 1
 */
public class GameManager {
    private  Board board;
    private  Pieces pieces;

    /**
     * Initialise a new board and piece set
     */
    public GameManager() {
        this.board = new Board();
        this.pieces = new Pieces();
    }

    /**
     * Defines the standard turn: a stone is picked from the correct bag and placed on the board
     *
     * @param piece    the number of the selected piece
     * @param position position on the board
     * @throws IllegalArgumentException if the piece isn't available or the space on the board is used
     */
    public void turn(int piece, int[] position) {
        //check if the piece is already placed
        if (!this.pieces.getPiece(piece).isPlaced()) {
            //catch the exception when the space on the board is already in use
            try {
                this.board.placePiece(piece, position);
                this.pieces.getPiece(piece).setPlaced();
            } catch (IllegalArgumentException e) {
                Terminal.printLine("The space on the board is already in use");
                throw new IllegalArgumentException();
            }
        } else {
            Terminal.printLine("The piece chosen is already in use");
            throw new IllegalArgumentException();
        }
    }

    /**
     * Check for the win condition
     * It looks for 4 strings of pieces with similar attributes
     * @param fourStringArray inputs the four string matrix generated by the FindFourStringMethod
     * @return true if the game is won
     */
    public boolean checkWin(Piece[][] fourStringArray) {
        //Iterate through all four Strings
        if (fourStringArray != null) {
            for (Piece[] fourString : fourStringArray) {
                if (pieces.comparePiece(fourString)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Find 4 strings on the board (non wrap-around)
     * @param gameMode the current game mode
     * @throws IllegalArgumentException if there are no stones placed on the board
     * @return Type:Piece[][4] where the first index gives access to the four Strings in the second one
     */
    public Piece[][] findFourStringNormal(Arguments gameMode) {
        //A List of Array containing the 4 strings
        ArrayList<Piece[]> fourString = new ArrayList<>();

        try {
            board.usedPositions();
        } catch (NullPointerException n) {
            Terminal.printError("No Stones are placed");
            throw new IllegalArgumentException();
        }
        Position[] positions = board.usedPositions();
        //Iterate through every stone on the board
        for (Position position : positions) {
            try {
                this.board.adjacentStonesStandard(position, gameMode);
            } catch (NullPointerException n) {
                continue;
            }
            //Iterate through every direction
            for (Position adjacentPosition : this.board.adjacentStonesStandard(position, gameMode)) {
                Piece[] piecesTemp = new Piece[4];
                piecesTemp[0] = this.board.getPiece(position, gameMode);
                //check if there are 4 stones in the same direction
                int directionX = adjacentPosition.getX() - position.getX();
                int directionY = adjacentPosition.getY() - position.getY();
                for (int i = 0; i < 4; i++) {
                    adjacentPosition.setX(( position.getX() + ( directionX * i )));
                    adjacentPosition.setY(( position.getY() + ( directionY * i )));
                    if (this.board.getPiece(adjacentPosition, gameMode) != null) {
                        piecesTemp[i] = this.board.getPiece(adjacentPosition, gameMode);
                    } else {
                        //break the loop if one stone os missing
                        break;
                    }
                }
                //check if the last spot has a stone
                if (piecesTemp[3] != null) {
                    fourString.add(piecesTemp);
                }
            }
        }
        //Type Cast for the toArray method
        Piece[][] returnArray = new Piece[fourString.size()][4];
        returnArray = fourString.toArray(returnArray);
        return returnArray;
    }

    /**
     * return the current board
     * @return board
     */
    public Board getBoard() {
        return board;
    }

    /**
     * return the state of the pieces
     * @return pieces
     */
    public Pieces getPieces() {
        return pieces;
    }

    /**
     * update the board
     * @param newBoard updated board
     */
    public void updateBoard(Board newBoard) {
        this.board = newBoard;
    }

    /**
     * update the pieces
     * @param newPieces updated pieces
     */
    public void updatePieces(Pieces newPieces) {
        this.pieces = newPieces;
    }
}
